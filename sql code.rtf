{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \
/* Create a function in your own database that takes two \
   parameters: \
1) A year parameter  \
2) A month parameter \
   The function then calculates and returns the total sale  \
   for the requested year and month. If there was no sale \
   for the requested period, returns 0. \
 \
   Hints: a) Use the TotalDue column of the  \
             Sales.SalesOrderHeader table in an \
             AdventureWorks database for \
             calculating the total sale. \
          b) The year and month parameters should use  \
             the INT data type. \
          c) Make sure the function returns 0 if there \
             was no sale in the database for the requested \
             period. */\
\
CREATE DATABASE pcp_Tot_sales;\
USE pcp_Tot_sales;\
\
CREATE FUNCTION dbo.TOT_SALES(@YEAR INT, @MONTH INT)\
RETURNS FLOAT\
AS \
BEGIN\
	DECLARE @tot_sales FLOAT;\
	(\
	SELECT @tot_sales = SUM(soh.TotalDue)  \
  	FROM [AdventureWorks2008R2].Sales.SalesOrderHeader AS soh\
  	-- I included AdventureWorks to coonect it to my database and retrieve information from AdventureWorks.\
  	GROUP BY YEAR(soh.OrderDate), MONTH(soh.orderdate)\
  	HAVING CAST(YEAR( soh.OrderDate) AS INT) = @YEAR AND CAST(MONTH(soh.OrderDate) AS INT)= @MONTH\
  	)\
    IF (@tot_sales IS NULL)\
    BEGIN\
    	SET @tot_sales = 0\
    END\
  	RETURN @tot_sales \
END;\
\
SELECT dbo.TOT_SALES(2005,08) [Total Sales];\
\
SELECT dbo.TOT_SALES(2012,08) [Total Sales];\
\
\
\
\
\
\
\
\
\
\
\
\
/* Create a table in your own database using the following statement. \
\
CREATE TABLE DateRange \
(DateID INT IDENTITY,  \
 DateValue DATE, \
 Month INT, \
 DayOfWeek INT); \
 \
Write a stored procedure that accepts two parameters: \
1)  A starting date  \
2)  The number of the consecutive dates beginning with the starting \
date \
The stored procedure then populates all columns of the \
DateRange table according to the two provided parameters */\
\
USE pcp_TOT_SALES;\
\
DROP TABLE IF EXISTS DateRange;\
--If we need new data only in the table, we need to drop table and create new one to avoid filling new data in same table.\
--Otherwise we can run same execution again which will fill the data in existing table data\
\
CREATE TABLE DateRange\
(\
DateID INT IDENTITY,\
DateValue DATE, \
Month INT, \
DayOfWeek INT\
)\
\
DROP PROCEDURE dbo.fnDateRange;\
--We can either drop the procedure to reset the procedure or use ALTER command to alter the procedure.\
\
--We run procedure code\
CREATE PROCEDURE fnDateRange(@Start_Date DATE, @Consec_Dates INT OUTPUT)\
AS\
BEGIN\
     DECLARE @Counter INT = 0; \
     WHILE (@Counter < @Consec_Dates)\
	 BEGIN\
	    INSERT INTO DateRange\
		VALUES\
		(\
		--@Counter + 1,\
		DATEADD(DAY, @Counter, @Start_Date),\
		MONTH(DATEADD(DAY, @Counter,@Start_Date)), \
        DAY(DATEADD(DAY, @Counter,@Start_Date))\
		);\
		-- SET @Start_Date = DATEADD(DAY, @Counter + 1, @Start_Date);\
        SET @Counter += 1\
	END\
END\
--We run execution code\
EXEC fnDateRange @Start_Date = '2017-07-25', @Consec_Dates = 10\
--We run selection code\
SELECT * FROM DateRange;\
\
\
\
/* With three tables as defined below: */ \
 \
/* Write a trigger to update the CustomerStatus column of Customer  \
   based on the total of OrderAmountBeforeTax for all orders  \
   placed by the customer. If the total exceeds 5,000, put Preferred \
   in the CustomerStatus column. */ \
\
USE pcp_TOT_SALES;\
\
DROP TABLE dbo.Customer;\
DROP TABLE dbo.SaleOrder;\
DROP TABLE dbo.SaleOrderDetail;\
-- dropping tables if empty dataset is desired.\
DROP TRIGGER dbo.update_status;\
--dropping and creating trigger to reset trigger\
\
CREATE TABLE dbo.Customer\
(\
CustomerID VARCHAR(20) PRIMARY KEY,\
CustomerLName VARCHAR(30),\
CustomerFName VARCHAR(30),\
CustomerStatus VARCHAR(10)\
); \
 \
CREATE TABLE dbo.SaleOrder\
(\
OrderID INT IDENTITY PRIMARY KEY,\
CustomerID VARCHAR(20) REFERENCES Customer(CustomerID),\
OrderDate DATE,\
OrderAmountBeforeTax INT\
);\
 \
CREATE TABLE dbo.SaleOrderDetail \
(\
OrderID INT REFERENCES SaleOrder(OrderID), \
ProductID INT,\
Quantity INT,\
UnitPrice INT,\
PRIMARY KEY (OrderID, ProductID)\
);\
\
-- Running the trigger creation code\
CREATE TRIGGER dbo.update_status\
ON dbo.SaleOrder\
AFTER INSERT, UPDATE, DELETE\
AS\
BEGIN\
	DECLARE @NewID INT;\
	DECLARE @status_customer VARCHAR(10);\
	DECLARE @AmountBTax FLOAT;\
	SELECT @NewID = ins.CustomerID\
	FROM INSERTED ins\
	FULL JOIN DELETED del\
		ON ins.customerid = del.customerid;\
\
	SET @AmountBTax = ( SELECT SUM(OrderAmountBeforeTax) FROM dbo.SaleOrder WHERE CustomerID = @NewID);\
\
	IF @AmountBTax > 5000\
		SET @status_customer = 'Preffered'\
	ELSE\
		SET @status_customer = 'Normal'\
UPDATE Customer set CustomerStatus = @status_customer\
WHERE CustomerID = @NewID;\
END;\
\
--Inserting some value in customer table\
INSERT into dbo.Customer VALUES ('1','Pranav','P','Normal');\
\
--Inserting some values in SaleOrder table to see if trigger works after condition is checked\
INSERT into dbo.SaleOrder VALUES ('1','1998-10-18',600);\
\
SELECT * FROM dbo.Customer;\
\
SELECT * FROM dbo.SaleOrder;\
\
UPDATE dbo.SaleOrder SET OrderAmountBeforeTax = 1000\
	WHERE orderid = 1 AND CustomerID = '1' AND OrderDate = '1998-10-18';\
\
DELETE FROM dbo.SaleOrder WHERE orderid = 1 AND CustomerID = '1' AND OrderDate = '1998-10-18';\
\
\
\
\
--Part 1\
\
CREATE DATABASE PranavCP;\
\
USE PranavCP;\
\
Drop table if exists TargetCustomers;\
Drop table if exists MailingLists;\
 \
CREATE TABLE TargetCustomers\
(\
	TargetId INT PRIMARY KEY IDENTITY NOT NULL,\
	First_Name NVARCHAR(50)  NULL,\
	Last_Name NVARCHAR(50)  NULL,\
	Address NVARCHAR(50)  NULL,\
	City NVARCHAR(50)  NULL,\
	State NVARCHAR(50) NULL,\
	ZipCode NVARCHAR(50) NULL\
);\
\
\
CREATE TABLE MailingLists\
(\
	MailingListId INT PRIMARY KEY IDENTITY NOT NULL,\
	MailingList NVARCHAR(50)  NULL\
);\
\
\
CREATE TABLE TargetMailingLists\
(\
	TargetId INT NOT NULL,\
	MailingListId INT NOT NULL,\
	PRIMARY KEY (TargetId, MailingListId),\
	FOREIGN KEY (TargetId) REFERENCES TargetCustomers(TargetId),\
	FOREIGN KEY (MailingListId) REFERENCES MailingLists(MailingListId)\
);\
\
\
\
\
---------------------------------------------------------------------------------------------------------------------------------------------\
\
\
\
--Part 2\
\
USE AdventureWorks2008R2;\
\
/* Using the content of AdventureWorks, write a query to retrieve \
   all unique customers with all salespeople they have dealt with. \
   If a customer has never worked with a salesperson, make the \
   'Salesperson ID' column blank instead of displaying NULL. \
   Sort the returned data by CustomerID in the descending order. \
   The result should have the following format. \
 \
   Hint: Use the SalesOrderHeadrer table. */\
\
\
select CustomerID, SalesPersonID\
FROM Sales.SalesOrderHeader\
where customerID = 30118\
\
SELECT\
	soh2.CustomerID,\
	STUFF\
		(\
			(\
			SELECT DISTINCT ', ' + RTRIM(isnull(CAST(soh.SalesPersonID AS CHAR), ''))\
			FROM Sales.SalesOrderHeader soh\
			WHERE soh.CustomerID = soh2.CustomerID\
			FOR XML PATH('')\
			), 1, 2, ''\
		) AS SalesPersonID \
From Sales.SalesOrderHeader soh2\
GROUP BY soh2.CustomerID \
ORDER BY CustomerID DESC\
\
\
\
Use AdventureWorks2008R2;\
SELECT distinct c.CustomerID,\
COALESCE( STUFF((SELECT  distinct ', '+RTRIM(CAST(SalesPersonID as char))  \
       FROM Sales.SalesOrderHeader \
       WHERE CustomerID = c.customerid\
       FOR XML PATH('')) , 1, 2, '') , '')  AS SalesPersons\
FROM Sales.Customer c\
left join Sales.SalesOrderHeader oh on c.customerID = oh.CustomerID\
order by c.CustomerID desc;\
\
\
\
\
---------------------------------------------------------------------------------------------------------------------------------------------\
\
\
\
\
/* Using the content of AdventureWorks, write a query to retrieve the top five  \
     products for each year. Use OrderQty of SalesOrderDetail to calculate the total quantity sold. \
     The top five products have the five highest sold quantities.  Also calculate the top five products'  \
     sold quantity for a year as a percentage of the total quantity sold for the year. */\
\
WITH TEMP1 AS\
	(\
	SELECT \
		YEAR(soh.OrderDate) YEAR,\
		SUM(sod.OrderQty) AS ttq,\
		sod.ProductID, \
    	RANK() OVER (PARTITION BY YEAR(soh.OrderDate) ORDER BY SUM(sod.OrderQty) DESC) AS RANK\
    FROM Sales.SalesOrderDetail sod\
    JOIN Sales.SalesOrderHeader soh\
    	ON sod.SalesOrderID=soh.SalesOrderID\
    GROUP BY YEAR(soh.OrderDate), sod.ProductID\
    )\
SELECT\
	TEMP1.YEAR,\
	((CAST(SUM(ttq) AS FLOAT) / CAST(ttq1 AS FLOAT) ) * 100) AS [Percentage_of_Total_Sale],\
	STUFF\
		(\
			(\
			SELECT TOP 5  ', ' + RTRIM(CAST(ProductID AS CHAR))\
			FROM Sales.SalesOrderDetail sod \
       		JOIN Sales.SalesOrderHeader soh\
       			ON Sod.SalesOrderID=soh.SalesOrderID\
       		WHERE YEAR(soh.OrderDate) = TEMP1.YEAR\
       		GROUP BY ProductID\
       		ORDER BY  SUM(OrderQty) DESC\
       		FOR XML PATH('')\
       		) , 1, 1, ''\
       	) AS Top5Products\
FROM TEMP1 \
JOIN\
	(\
	SELECT\
		YEAR(soh.OrderDate) YEAR,\
		SUM(sod.OrderQty) AS ttq1\
 	FROM Sales.SalesOrderDetail sod\
    JOIN Sales.SalesOrderHeader soh\
    	ON sod.SalesOrderID=soh.SalesOrderID\
    GROUP BY YEAR(soh.OrderDate)\
	) TEMP2\
	ON TEMP1.YEAR = TEMP2.YEAR \
WHERE TEMP1.RANK <=5\
GROUP BY TEMP1.YEAR, TEMP2.ttq1 \
ORDER BY YEAR;\
\
\
\
\
WITH Temp1 AS\
   (select year(OrderDate) Year, ProductID, sum(OrderQty) ttl,\
    rank() over (partition by year(OrderDate) order by sum(OrderQty) desc) as \
TopProduct\
    from Sales.SalesOrderHeader sh\
join Sales.SalesOrderDetail sd\
on sh.SalesOrderID = sd.SalesOrderID\
    group by year(OrderDate), ProductID) ,\
Temp2 AS\
   (select year(OrderDate) Year, sum(OrderQty) ttl\
    from Sales.SalesOrderHeader sh\
join Sales.SalesOrderDetail sd\
on sh.SalesOrderID = sd.SalesOrderID\
    group by year(OrderDate))\
select t1.Year, cast(sum(t1.ttl) as decimal) / t2.ttl * 100 [% of Total Sale],\
STUFF((SELECT  ', '+RTRIM(CAST(ProductID as char))  \
       FROM temp1 \
       WHERE Year = t1.Year and TopProduct <=5\
       FOR XML PATH('')) , 1, 2, '') AS Top5Products\
from temp1 t1\
join temp2 t2\
on t1.Year=t2.Year\
where t1.TopProduct <= 5\
group by t1.Year, t2.ttl;\
\
\
\
\
\
---------------------------------------------------------------------------------------------------------------------------------------------\
\
\
\
\
\
/* Bill of Materials - Recursive */ \
/* Use Adventureworks */ \
/* The following code retrieves the components required for manufacturing \
   the "Mountain-500 Black, 48" (Product 992). Use it as the starter code \
   for calculating the material cost reduction if the component 815 \
   is manufactured internally at the level 1 instead of purchasing it \
   for use at the level 0. Use the list price of a component as \
   the material cost for the component. */ \
 \
-- Starter code\
\
WITH Parts(AssemblyID, ComponentID, PerAssemblyQty, EndDate, ComponentLevel) AS \
( \
    SELECT b.ProductAssemblyID, b.ComponentID, b.PerAssemblyQty, \
           b.EndDate, 0 AS ComponentLevel \
    FROM Production.BillOfMaterials AS b \
    WHERE b.ProductAssemblyID = 992 AND b.EndDate IS NULL \
    UNION ALL \
    SELECT bom.ProductAssemblyID, bom.ComponentID, p.PerAssemblyQty, \
           bom.EndDate, ComponentLevel + 1 \
    FROM Production.BillOfMaterials AS bom  \
    INNER JOIN Parts AS p \
    ON bom.ProductAssemblyID = p.ComponentID AND bom.EndDate IS NULL \
)\
SELECT AssemblyID, ComponentID, Name, PerAssemblyQty, ComponentLevel \
FROM Parts AS p \
INNER JOIN Production.Product AS pr \
ON p.ComponentID = pr.ProductID \
ORDER BY ComponentLevel, AssemblyID, ComponentID;\
\
/*Part C*/\
DECLARE @SumOfLevel0 FLOAT;\
DECLARE @SumOfLevel1 FLOAT;\
DECLARE @CostReduction FLOAT;\
WITH Parts(AssemblyID, ComponentID, PerAssemblyQty, EndDate, ComponentLevel) AS \
( \
    SELECT b.ProductAssemblyID, b.ComponentID, b.PerAssemblyQty, \
           b.EndDate, 0 AS ComponentLevel \
    FROM Production.BillOfMaterials AS b \
    WHERE b.ProductAssemblyID = 992 AND b.EndDate IS NULL \
    UNION ALL \
    SELECT bom.ProductAssemblyID, bom.ComponentID, p.PerAssemblyQty, \
           bom.EndDate, ComponentLevel + 1 \
    FROM Production.BillOfMaterials AS bom  \
    INNER JOIN Parts AS p \
    ON bom.ProductAssemblyID = p.ComponentID AND bom.EndDate IS NULL \
)\
\
SELECT @SumOfLevel1 =\
(\
SELECT --AssemblyID, ComponentID, Name, ListPrice, PerAssemblyQty,ComponentLevel--,listprice\
SUM(ListPrice) AS Sumof\
FROM Parts AS p\
INNER JOIN Production.Product AS pr\
ON p.ComponentID =pr.ProductID \
Group by AssemblyID--,ComponentID, Name, PerAssemblyQty,ComponentLevel,ListPrice\
having AssemblyID = 815\
);\
\
--Declare @SumOfLevel0 Float;\
--Declare @SumOfLevel0 Float;\
WITH Parts(AssemblyID, ComponentID, PerAssemblyQty, EndDate, ComponentLevel) AS \
( \
    SELECT b.ProductAssemblyID, b.ComponentID, b.PerAssemblyQty, \
           b.EndDate, 0 AS ComponentLevel \
    FROM Production.BillOfMaterials AS b \
    WHERE b.ProductAssemblyID = 992 AND b.EndDate IS NULL \
    UNION ALL \
    SELECT bom.ProductAssemblyID, bom.ComponentID, p.PerAssemblyQty, \
           bom.EndDate, ComponentLevel + 1 \
    FROM Production.BillOfMaterials AS bom  \
    INNER JOIN Parts AS p \
    ON bom.ProductAssemblyID = p.ComponentID AND bom.EndDate IS NULL \
)\
\
 select @SumOfLevel0=\
(\
SELECT --AssemblyID, ComponentID, Name, ListPrice, PerAssemblyQty,ComponentLevel,\
\
(ListPrice) as Sumof\
FROM Parts AS p2\
INNER JOIN Production.Product AS pr \
ON p2.ComponentID =pr.ProductID\
 \
where ComponentID = 815 and AssemblyID = 992\
);\
 \
 select @CostReduction=\
(\
\
(@SumOfLevel0  - @SumOfLevel1)\
)\
\
print @CostReduction;\
\
\
\
\
IF OBJECT_ID('tempdb..#TempTable') IS NOT NULL\
DROP TABLE #TempTable;\
\
WITH Parts(AssemblyID, ComponentID, PerAssemblyQty, EndDate, ComponentLevel) AS\
(\
    -- Top-level compoments\
SELECT b.ProductAssemblyID, b.ComponentID, b.PerAssemblyQty,\
        b.EndDate, 0 AS ComponentLevel\
    FROM Production.BillOfMaterials AS b\
    WHERE b.ProductAssemblyID = 992\
          AND b.EndDate IS NULL\
    UNION ALL\
-- All other sub-compoments\
    SELECT bom.ProductAssemblyID, bom.ComponentID, p.PerAssemblyQty,\
        bom.EndDate, ComponentLevel + 1\
    FROM Production.BillOfMaterials AS bom \
        INNER JOIN Parts AS p\
        ON bom.ProductAssemblyID = p.ComponentID\
        AND bom.EndDate IS NULL\
)\
SELECT AssemblyID, ComponentID, Name, ListPrice, PerAssemblyQty, \
       ListPrice * PerAssemblyQty SubTotal, ComponentLevel\
into #TempTable\
FROM Parts AS p\
    INNER JOIN Production.Product AS pr\
    ON p.ComponentID = pr.ProductID\
ORDER BY ComponentLevel, AssemblyID, ComponentID;\
SELECT\
	(SELECT ListPrice\
	FROM #TempTable\
	WHERE ComponentLevel = 0 and ComponentID = 815),\
	(SELECT SUM(ListPrice)\
	FROM #TempTable\
	WHERE ComponentLevel = 1 and AssemblyID = 815) AS [Price_Difference];\
	\
\
\
\
\
\
---------------------------------------------------------------------------------------------------------------------------------------------\
\
\
\
\
\
\
\
USE AdventureWorks2008R2\
\
WITH temp AS\
	(\
	SELECT TERRITORYID, CustomerID,\
	RANK() OVER(PARTITION BY TERRITORYID ORDER BY COUNT(SalesOrderID) DESC) AS CustomerRank\
	FROM Sales.SalesOrderHeader\
	GROUP BY TERRITORYID, CustomerID\
	)\
SELECT DISTINCT\
	TERRITORYID,\
	STUFF (\
			(\
			SELECT ', ' + CAST(CustomerID AS CHAR (5))\
			FROM temp t2\
			WHERE t2.TERRITORYID = t1.TERRITORYID AND CustomerRank = 1\
			ORDER BY CustomerID\
			FOR XML PATH('')), 1, 2, '') TopCustomers\
FROM temp t1;\
\
\
\
\
\
\
/* Q1\
Year	Week Day	Monday	Tuesday	Wednesday	Thursday	Friday	Saturday	Sunday\
2006	Total Sales								8164751				6749180	\
2007	Total Sales	6639424	5590523				6379290		9967385				10042829\
2008	Total Sales					5814991				\
\
\
\
*/\
\
select datepart(yy, OrderDate) Year,\
       datepart(dw, OrderDate) as WeekDay,\
       cast(sum(TotalDue) as int) as TotalSales\
from Sales.SalesOrderHeader\
where year(OrderDate) between 2006 and 2008\
group by datepart(dw, OrderDate),  datepart(yy, OrderDate)\
having sum(TotalDue) > 5500000\
\
USE AdventureWorks2008R2;\
\
\
	SELECT Year,'Total Sales',	ISNULL([1], ' ') AS 'Monday' ,\
							ISNULL([2], ' ') AS 'Tuesday',\
							ISNULL([3], ' ') AS 'Wednesday',\
							ISNULL([4], ' ') AS 'Thursday',\
							ISNULL([5], ' ') AS 'Friday',\
							ISNULL([6], ' ') AS 'Saturday',\
							ISNULL([7], ' ') AS 'Sunday'\
FROM\
(\
	select datepart(yy, OrderDate) Year,\
       datepart(dw, OrderDate) as WeekDay,\
       cast(sum(TotalDue) as int) as TotalSales\
from Sales.SalesOrderHeader\
where year(OrderDate) between 2006 and 2008\
group by datepart(dw, OrderDate),  datepart(yy, OrderDate)\
having sum(TotalDue) > 5500000\
) AS SourceTable\
PIVOT\
(\
	SUM(TotalSales)\
	FOR WeekDay\
	IN ([1], [2], [3], [4], [5], [6], [7])\
\
) AS PivotTable\
	\
\
\
--------------------------------------------------------------------------------------------------------------------------------------------------\
\
\
\
	\
/* Q2\
\
Using AdventureWorks2008R2, write a query to retrieve \
the order years and their order info.\
\
Return the year, a year's total sales, the top 3 \
order values of a year, and the total of the top 3 \
order values as a percentage of a year's total sales.\
\
The top 3 order values are the 3 highest order values. \
Use TotalDue in SalesOrderHeader as the order value. \
Please keep in mind it's the order value and several orders \
may have the same value. \
\
Return only the top 2 years. The top 2 years have the 2 highest\
total sales. If there is a tie, the tie needs to be retrieved.\
\
Sort the returned data by year. Return the data in\
the format specified below.\
*/\
\
/*\
Year	TotalSales	Top 3 Order Values					Percentage\
2006	34463848	170512.67, 166537.08, 165028.75		1.45\
2007	47171490	187487.83, 182018.63, 145454.37		1.09\
*/\
\
\
*/	\
\
USE AdventureWorks2008R2;\
\
WITH TEMP AS\
(\
	SELECT YEAR(soh.OrderDate) YEAR, ProductID,SOH.TotalDue AS 'TTQ',\
    DENSE_RANK() OVER (Partition By YEAR(soh.OrderDate) ORDER BY SOH.TotalDue DESC) AS 'Rank'\
    FROM Sales.SalesOrderDetail SOD\
    join Sales.SalesOrderHeader SOH\
    ON SOD.SalesOrderID=SOH.SalesOrderID\
    group by YEAR(soh.OrderDate), SOD.ProductID,SOH.TotalDue\
)\
SELECT TEMP.YEAR,TTQ1 as [TotSales], (( CAST(SUM(TTQ) AS FLOAT)  / CAST(TTQ1 AS FLOAT) ) * 100 ) AS 'Percentage',\
STUFF((SELECT TOP 3  ', '+RTRIM(CAST(SOH.TotalDue AS char))  \
       FROM Sales.SalesOrderDetail SOD \
       JOIN Sales.SalesOrderHeader SOH\
       ON SOD.SalesOrderID=SOH.SalesOrderID\
       WHERE YEAR(soh.OrderDate) = TEMP.YEAR\
	   GROUP BY SOH.TotalDue\
       ORDER BY  SOH.TotalDue  DESC\
       FOR XML PATH('')) , 1, 1, '') AS 'Top3Order Values'\
FROM TEMP \
JOIN \
(\
	SELECT YEAR(soh.OrderDate) YEAR, SUM(SOH.TotalDue) AS 'TTQ1'\
 	FROM Sales.SalesOrderHeader SOH\
    --JOIN Sales.SalesOrderHeader SOH\
    --ON SOD.SalesOrderID=SOH.SalesOrderID\
    GROUP BY YEAR(soh.OrderDate)\
      ) B\
ON TEMP.YEAR =B.YEAR \
WHERE TEMP.Rank <=3\
GROUP BY TEMP.YEAR,B.TTQ1 \
ORDER BY TEMP.YEAR;\
\
\
USE AdventureWorks2008R2;}